# [üß† Apuntes de **Git** y **GitHub**](https://rxnwashere.github.io/rxnwashere_apuntes_git/)

## üìë Contenidos

1. [üß© ¬øQu√© es Git?](#que-es-git)  
2. [üîÑ Ciclo de vida de los archivos en Git](#ciclo-de-vida-de-los-archivos-en-git)  
   - [üìä Fases principales](#fases-principales)  
3. [‚öôÔ∏è Configuraci√≥n inicial](#configuracion-inicial)  
4. [üóÇÔ∏è Crear y gestionar repositorios](#crear-y-gestionar-repositorios)  
5. [üìÅ Flujo de trabajo completo](#flujo-de-trabajo-completo)  
   - [1Ô∏è‚É£ Working Directory ‚Üí Staging Area](#working-directory--staging-area)  
   - [2Ô∏è‚É£ Staging Area ‚Üí Repository (commit)](#staging-area--repository-commit)  
   - [3Ô∏è‚É£ Repository ‚Üí Remote Repository](#repository--remote-repository)  
   - [4Ô∏è‚É£ Remote Repository ‚Üí Repository](#remote-repository--repository)  
6. [ü™Ñ Modificar y deshacer cambios](#modificar-y-deshacer-cambios)  
7. [üåø Ramas (branches)](#ramas-branches)  
8. [‚òÅÔ∏è Remotos (GitHub y otros)](#remotos-github-y-otros)  
9. [üîç Comparar y revisar cambios](#comparar-y-revisar-cambios)  
10. [üîß Ignorar archivos](#ignorar-archivos)  
11. [üí° Flujo de trabajo t√≠pico](#flujo-de-trabajo-t√≠pico)  
12. [üß∞ Comandos √∫tiles](#comandos-utiles)  
13. [üîê SSH con GitHub](#ssh-con-github)  
14. [üìö Recursos recomendados](#recursos-recomendados)

---

<a id="que-es-git"></a>
## üß© ¬øQu√© es Git?
**Git** es un sistema de control de versiones distribuido.  
Permite registrar los cambios realizados en un proyecto, volver a versiones anteriores, trabajar en equipo y fusionar c√≥digo f√°cilmente.

---

<a id="ciclo-de-vida-de-los-archivos-en-git"></a>
## üîÑ Ciclo de vida de los archivos en Git

Git maneja **cuatro estados principales** en los que puede estar un archivo:

| Estado | Descripci√≥n |
|--------|--------------|
| **Untracked** | El archivo existe en tu carpeta, pero Git no lo est√° controlando. |
| **Tracked** | El archivo ya fue a√±adido al control de versiones. |
| **Staged** | El archivo ha sido preparado para el siguiente commit (`git add`). |
| **Committed** | El archivo ya est√° guardado en la base de datos de Git (`git commit`). |

<a id="fases-principales"></a>
### üìä Fases principales

```
[ Working Directory ] ‚Üí git add ‚Üí [ Staging Area ] ‚Üí git commit ‚Üí [ Local Repository ] ‚Üí git push ‚Üí [ Remote Repository (GitHub) ]
```

- **Working Directory**: tus archivos reales.
- **Staging Area** (o **index**): una ‚Äúzona intermedia‚Äù donde eliges qu√© cambios se guardar√°n en el pr√≥ximo commit.
- **Local Repository**: historial de commits en tu m√°quina.
- **Remote Repository**: copia del repo en un servidor (GitHub, GitLab, etc.).

---

<a id="configuracion-inicial"></a>
## ‚öôÔ∏è Configuraci√≥n inicial

```bash
git config --global user.name "Tu Nombre"
git config --global user.email "tuemail@example.com"
git config --list
git config --global --edit # Abrir configuraci√≥n global con editor de texto.
git config --global core.editor "nano" # Configurar editor por defecto (cambia nano por vscode o el editor de tu elecci√≥n)
```

---

<a id="crear-y-gestionar-repositorios"></a>
## üóÇÔ∏è Crear y gestionar repositorios

```bash
git init                      # Inicia un nuevo repositorio en la carpeta actual
git clone <URL>               # Clona un repositorio existente (de GitHub u otro servidor)
```

---

<a id="flujo-de-trabajo-completo"></a>
## üìÅ Flujo de trabajo completo

<a id="working-directory--staging-area"></a>
### 1Ô∏è‚É£ Working Directory ‚Üí Staging Area
A√±adimos archivos a la zona de preparaci√≥n.

```bash
git add <archivo>             # A√±adir un archivo
git add .                     # A√±adir todos los cambios
git status                    # Ver el estado actual de los archivos en el repositorio
```

<a id="staging-area--repository-commit"></a>
### 2Ô∏è‚É£ Staging Area ‚Üí Repository (commit)
Guardamos los cambios en la base de datos local de Git.

```bash
git commit -m "Mensaje del commit"   # Confirmar los cambios preparados. Tambi√©n podemos hacer git commit sin el par√°metro -m, pero en lugar de hacer el commit con el mensaje directamente nos abrir√° el editor por defecto que hayamos configurado.
```

<a id="repository--remote-repository"></a>
### 3Ô∏è‚É£ Repository ‚Üí Remote Repository
Subimos nuestros commits al servidor remoto (GitHub).

```bash
git push origin main                 # Subir cambios a la rama main
git push --set-upstream origin main  # Primera vez, vincula la rama local con la remota
```

<a id="remote-repository--repository"></a>
### 4Ô∏è‚É£ Remote Repository ‚Üí Repository
Descargamos o actualizamos los cambios remotos.

```bash
git pull origin main                 # Descargar y fusionar cambios
git fetch                            # Descargar sin fusionar (solo actualiza la info remota)
```

En caso que el repositorio remoto este "1 commit behind" del repositorio local (Siguiente ejemplo);

```bash
origin/main:  A --- B --- C   # Commits repositorio remoto
local/main:   A --- B --- D   # Commits repositorio local
```

Si hacemos "git pull" git no va a preguntar c√≥mo queremos fusionar los cambios, tenemos dos opciones:

1 - Crear un "merge commit" que combina el repositorio local con el repositorio remoto. 

```bash
git pull --no-rebase
          D         # Commits repositorio local
         /
A --- B --- C       # Commits repositorio remoto
         \
          M  (merge commit)  # Nuevo merge commit

```

**Pros**: No se modifican los commits, seguro para ramas compartidas.  
**Cons**: Crea "merge commits" adicionales, el historial puede parecer m√°s ca√≥tico.

2 - Git fusiona los cambios y crea un nuevo commit, haciendo el historial lineal.

```bash
git pull --rebase

A --- B --- C --- D    # D es el commit local, "rebased" con C
```

**Pros**: Limpio, historial lineal, f√°cil de leer.  
**Cons**: Reescribe los ID's de los commits, no es seguro para ramas compartidas. 

Si no queremos que git nos avise cada vez que nos encontramos en esta situaci√≥n, podemos configurar el comportamiento por defecto:

```bash
git config pull.rebase false   # Hacer siempre merge
git config pull.rebase true    # Hacer siempre rebase
```

---

<a id="modificar-y-deshacer-cambios"></a>
## ü™Ñ Modificar y deshacer cambios

```bash
git restore --staged <archivo>   # Quitar un archivo del √°rea de stage
git restore <archivo>            # Deshacer cambios en el working directory
git revert <id_commit>           # Crear un commit que revierta otro
git reset --hard <id_commit>     # Volver el repo a un commit anterior (borra cambios)
```

---

<a id="ramas-branches"></a>
## üåø Ramas (branches)

```bash
git branch                       # Ver ramas
git branch -r                    # Ver ramas remotas
git branch -a                    # Ver ramas locales y remotas

git branch <nombre>              # Crear una rama
git branch -d <nombre>           # Borrar una rama

git switch <nombre>              # Cambiar de rama
git checkout <nombre>

git switch -c <nombre>           # Crear y cambiar a la vez
git checkout -b <nombre>

git merge <nombre>               # Fusionar una rama con la actual. No genera commit de merge, solo mueve el puntero de la rama hacia delante
git merge <nombre> --no-ff       # Fusiona una rama con la actual pero forzando dejar un commit de merge. --no-ff significa "No fast forward".
git merge <nombre> --allow-unrelated-histories # Fusionar una rama sin cambios relacionados con la actual
```

---

<a id="remotos-github-y-otros"></a>
## ‚òÅÔ∏è Remotos (GitHub y otros)

```bash
git remote add origin <URL HTTP> / <URL SSH> # Conectar el repo local a uno remoto
git remote -v                    # Ver los remotos configurados
git push                         # Subir cambios
git pull                         # Bajar y fusionar cambios
git fetch                        # Descargar sin fusionar
```

---

<a id="comparar-y-revisar-cambios"></a>
## üîç Comparar y revisar cambios

```bash
git diff                         # Ver diferencias entre archivos
git diff <commit1> <commit2>     # Comparar commits
git log --oneline --graph --all  # Ver el historial con ramas
git blame <archivo>              # Ver qui√©n cambi√≥ cada l√≠nea
```

---

<a id="ignorar-archivos"></a>
## üîß Ignorar archivos

Archivo `.gitignore`:
```
# Carpetas
node_modules/
dist/

# Archivos temporales
*.log
.env
```

---

<a id="flujo-de-trabajo-t√≠pico"></a>
## üí° Flujo de trabajo t√≠pico

```bash
git clone <url>
git checkout -b feature/nueva-funcionalidad
# (editar archivos)
git add .
git commit -m "A√±adida nueva funcionalidad"
git push origin feature/nueva-funcionalidad
# Crear Pull Request en GitHub
```

**EJEMPLO DE PULL REQUEST:**

Cuando entremos a nuestro repositorio desde GitHub a la nueva rama veremos un aviso que nos informar√° sobre los commits por delante o por detr√°s que est√° respecto a <code>main</code>, para este ejemplo estar√° un commit por delante.

Tambi√©n veremos una notificaci√≥n avisando de las ramas que han tenido pushes recientemente:

![Notificaci√≥n sobre pushes recientes y commits adelantados](imgs/pullreq1.png)

Presionaremos <code>Compare & Pull Request</code> para comprobar los cambios y fusionar ambas ramas:

![Cambios entre ficheros](imgs/pullreq2.png)

A√±adimos un nombre a nuestra request (puede coger el nombre de nuestro √∫ltimo commit en la rama a fusionar):

![T√≠tulo para nuestro pull request sin problemas de fusi√≥n](imgs/pullreq3.png)

Si nos fijamos arriba podremos observar que nos informa que est√° listo para fusionar autom√°ticamente debido a que no hay conflictos 
(<code>Able to merge</code>)

Al abrir la pull request si no hay conflictos como en este caso podremos hacer un <code>merge</code> con main:

![Pull y merge request. No hay conflictos entre ramas](imgs/pullreq4.png)

![Confirmaci√≥n de merge request](imgs/pullreq5.png)

Cuando se fusione, la pull request ser√° cerrada y podremos eliminar la rama si lo deseamos:

![Pull request exitosa](imgs/pullreq6.png)

![Cambios despu√©s del merge](imgs/pullreq7.png)

---

<a id="comandos-utiles"></a>
## üß∞ Comandos √∫tiles

```bash
git log --oneline                # Ver historial corto
git reflog                       # Ver todos los movimientos de HEAD
git clean -f                     # Borrar archivos no rastreados
```

---

<a id="ssh-con-github"></a>
## üîê SSH con GitHub

```bash
ssh-keygen -t ed25519 -C "tuemail@example.com"
cat ~/.ssh/id_ed25519.pub
```

Luego a√±ades el contenido de la clave a una nueva desde GitHub, podr√°s encontrar el men√∫ en:

![<code>Settings</code> (configuraci√≥n de tu cuenta de GitHub) --> <code>SSH and GPG Keys</code>](https://github.com/settings/keys)

![Men√∫ para a√±adir clave SSH p√∫blica](imgs/sshkeys.png)

---

<a id="recursos-recomendados"></a>
## üìö Recursos recomendados

- [Pro Git Book (en espa√±ol)](https://git-scm.com/book/es/v2)
- [Git Cheatsheet (GitHub)](https://education.github.com/git-cheat-sheet-education.pdf)
- [Learn Git Branching (interactivo)](https://learngitbranching.js.org/)
- [Documentaci√≥n oficial de Git](https://git-scm.com/docs)

<br>

<code>Hecho por Aar√≥n Cano ([rxnwashere](https://github.com/rxnwashere)) y revisado con ChatGPT</code>